<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java面试 | Rxbby</title><meta name="author" content="Pn,change125800@gmail.com"><meta name="copyright" content="Pn"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="String String的底层是由一个被final修饰的char[] value 实现的。   当使用构造器创建对象时String s &#x3D; new String (“hello”);  首先会在堆中创建一个对象，然后指向常量池中的字符串对象。  String a &#x3D; new String (“hello”); String  b &#x3D; new String (“hel">
<meta property="og:type" content="article">
<meta property="og:title" content="java面试">
<meta property="og:url" content="https://changettto.github.io/2023/12/07/java%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Rxbby">
<meta property="og:description" content="String String的底层是由一个被final修饰的char[] value 实现的。   当使用构造器创建对象时String s &#x3D; new String (“hello”);  首先会在堆中创建一个对象，然后指向常量池中的字符串对象。  String a &#x3D; new String (“hello”); String  b &#x3D; new String (“hel">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rxbby.oss-cn-guangzhou.aliyuncs.com/HuiYuan.jpg">
<meta property="article:published_time" content="2023-12-06T22:04:01.000Z">
<meta property="article:modified_time" content="2024-01-24T09:23:35.939Z">
<meta property="article:author" content="Pn">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rxbby.oss-cn-guangzhou.aliyuncs.com/HuiYuan.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://changettto.github.io/2023/12/07/java%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java面试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-24 17:23:35'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/HuiYuan.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.pinimg.com/originals/bf/da/38/bfda380e49cf7b40513372ff07985c20.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Rxbby"><span class="site-name">Rxbby</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java面试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-06T22:04:01.000Z" title="发表于 2023-12-07 06:04:01">2023-12-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-24T09:23:35.939Z" title="更新于 2024-01-24 17:23:35">2024-01-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java面试"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ul>
<li><p>String的底层是由一个被final修饰的char[] value 实现的。 </p>
</li>
<li><p>当使用构造器创建对象时String s &#x3D; new String (“hello”);</p>
</li>
<li><p>首先会在堆中创建一个对象，然后指向常量池中的字符串对象。</p>
</li>
<li><p>String a &#x3D; new String (“hello”); String  b &#x3D; new String (“hello”);创建了两个对象。    在栈中创建两个引用，堆中创建两个对象，但都指向常量池中的同一个对象。</p>
</li>
<li><p>当使用String a &#x3D; “hello”创建对象时</p>
</li>
<li><p>首先会在栈中创建出一个a 的对象引用，然后再指向常量池中的hello字符串对象所对应的地址。</p>
</li>
<li><p>String a &#x3D; “hello”  String b &#x3D; “hello”  创建了一个对象。两个引用指向常量池中的同一个地址。</p>
</li>
<li><p>String a &#x3D; “hello”  String b &#x3D; “helloo”  创建了两个对象。两个引用分别指向常量池中的不同对象地址。</p>
</li>
<li><p>每次创建新字符都会创建对象。</p>
</li>
</ul>
<h1 id="String、StringBuffer、StringBulider三者的区别"><a href="#String、StringBuffer、StringBulider三者的区别" class="headerlink" title="String、StringBuffer、StringBulider三者的区别"></a>String、StringBuffer、StringBulider三者的区别</h1><p>需要经常改变字符串内容时用后面两个。</p>
<ul>
<li>String是final修饰的，不可变，每次操作都会产生新的对象。</li>
<li>StringBuffer和StringBulider都是直接在原对象上进行操作，可以直接更新value数组的的字符串内容。不用创建新对象。</li>
<li>StringBuffer是线程安全的，而StringBulider是线程不安全的。</li>
<li>StringBuffer方法都是由Synchronized关键字修饰的。</li>
</ul>
<h1 id="finall关键字"><a href="#finall关键字" class="headerlink" title="finall关键字"></a>finall关键字</h1><ul>
<li><p>修饰类、属性、方法、局部变量</p>
</li>
<li><p>被修饰的属性一般叫做<strong>常量。</strong></p>
</li>
<li><p>final类不可继承，但可以实例化对象。</p>
</li>
<li><p>final往往和static搭配使用，在使用这个常量的时候不会导致类的加载。</p>
</li>
<li><p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698778691329-ab0eaf1e-f942-4c62-8567-50164545dcd2.png" alt="img"></p>
</li>
<li><p><strong>修饰类</strong></p>
</li>
<li><p>不可继承</p>
</li>
<li><p><strong>修饰属性</strong></p>
</li>
<li><p>值不可修改</p>
</li>
<li><p>必须赋初值</p>
</li>
<li><p>构造器里、代码块里、定义时赋值</p>
</li>
<li><p>如果修饰的属性是静态的，那么只能在代码块中和定义时初始化赋值，因为类加载是在构造器之前的。</p>
</li>
<li><p><strong>修饰方法</strong></p>
</li>
<li><p>不可重写，但可覆盖</p>
</li>
<li><p>局部变量</p>
</li>
<li><p>定义时可以不用赋值，但在使用前一定要赋值。不可修改值</p>
</li>
</ul>
<h1 id="和equals"><a href="#和equals" class="headerlink" title="&#x3D;&#x3D;和equals()"></a>&#x3D;&#x3D;和equals()</h1><p>1、&#x3D;&#x3D;</p>
<ul>
<li>既可以判断基本数据类型，又可以判断引用类型。</li>
<li>判断基本数据类型时，判断的是值是否相等。</li>
<li>判断引用类型时，判断的是地址是否相等。</li>
</ul>
<p>2、equals()</p>
<ul>
<li>默认的equals()方法只能判断引用类型，判断两者地址是否相等。</li>
<li>但一般都会重新equals()方法 ,重写为判断两者的值或者说内容是否相等。</li>
</ul>
<h1 id="为什么重写了equals-还要重写hashcode"><a href="#为什么重写了equals-还要重写hashcode" class="headerlink" title="为什么重写了equals()还要重写hashcode()?"></a>为什么重写了equals()还要重写hashcode()?</h1><p>hashCode：根据不同的对象地址返回一个int整数</p>
<p>重写hashCode:比如String就重写了，改为只要值相等那么hashCode就相等</p>
<p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/694975.html">https://www.51cto.com/article/694975.html</a></p>
<p>如果只重写了 equals 方法，Set集合在对<strong>不同地址但内容相同的对象</strong>进行去重时，会用到hashCode和equals方法，它会先判断两个对象的 hashCode 是否相同，此时因为没有重写 hashCode 方法，所以会直接执行 hashCode的原始方法，<strong>因为hashCode原始方法比的是两个对象的地址</strong>，然后他就会认为这是两个不同的对象，那么 equals 方法就得不到执行了，直接就会认为两个对象不是相等的，于是就在 Set 集合中插入了两个相同内容的对象。</p>
<p>但是，如果在重写 equals 方法时，也重写了 hashCode 方法，那么在执行判断时会去执行重写的 hashCode 方法，此时对比的是两个对象的所有属性的 hashCode 是否相同，相同之后呢，再去调用 equals 方法，发现两个对象确实是相等的，然后 Set 集合就不会存储两个一模一样的数据了。</p>
<p><strong>总结</strong></p>
<p>hashCode 和 equals 两个方法是用来协同判断两个对象是否相等的，如果在重写 equals 时，不重写 hashCode，就会导致在某些场景下，例如将两个相等的自定义对象存储在 Set 集合时，就会出现程序执行的异常，为了保证程序的正常执行，所以我们就需要在重写 equals 时，也一并重写 hashCode 方法才行。 </p>
<h1 id="list接口和set接口的区别"><a href="#list接口和set接口的区别" class="headerlink" title="list接口和set接口的区别"></a>list接口和set接口的区别</h1><ul>
<li>List：有序、可重复、按对象的进入顺序保存对象，允许多个Null元素对象，可以用迭代器、增强for，普通for，forEach来进行遍历，可以使用get(index)获取指定下标的元素。</li>
<li>set：无序、不可重复，只能存一个NUll对象，只能只用迭代器和增强for循环进行遍历，不能使用索引的方式遍历，因为不能使用get(index)获取指定下标的元素。</li>
</ul>
<h1 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h1><pre><code>  抽象类是用来继承的，接口是用来实现的
</code></pre>
<ul>
<li>抽象类可以有带有方法体的方法，而接口中只能存在 public abstract 方法；</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量隐式为public static final 类型的；</li>
<li>抽象类可以有静态代码块，但接口中不能含有静态代码块。</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><p><strong>重载：</strong>发生在一个类中，方法名必须相同，参数类型不同、参数个数不同、顺序不同、方法返回值和访问修饰符可以不同。</p>
<p><strong>重写：</strong>发生在父子类中，方法名、参数列表必须相同，返回值范围&lt;&#x3D;父类，抛出的异常范围&lt;&#x3D;父类，访问修饰符&gt;&#x3D;父类，如果父类的方法是private的则不能重写。</p>
<h1 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h1><h1 id="obj-hashCode和StringhashCode"><a href="#obj-hashCode和StringhashCode" class="headerlink" title="obj.hashCode和StringhashCode"></a>obj.hashCode和StringhashCode</h1><p>hash 算法是将任意对象，分配一个<strong>编号</strong>的过程，其中编号是一个有限范围内的数字（如 int 范围内）</p>
<p><strong>Object.hashCode</strong></p>
<ul>
<li>Object 的 hashCode 方法默认是生成随机数作为 hash 值（会缓存在对象头当中）</li>
<li>缺点是包含相同<strong>值</strong>的不同对象，他们的 hashCode 不一样，不能够用 hash 值来反映对象的<strong>值</strong>特征，因此诸多子类都会重写 hashCode 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;bac&quot;</span>;                     </span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);         </span><br><span class="line"></span><br><span class="line">    System.out.println(s1.hashCode());</span><br><span class="line">    System.out.println(s2.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原则：值相同的字符串生成相同的 hash 码, 尽量让值不同的字符串生成不同的 hash 码</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对于 abc  a * 100 + b * 10 + c</span></span><br><span class="line"><span class="comment">    对于 bac  b * 100 + a * 10 + c</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s1.charAt(i);</span><br><span class="line">        System.out.println((<span class="type">int</span>) c);</span><br><span class="line">        <span class="comment">// (a*10 + b)*10 + c  ==&gt;  a*100 + b*10 + c  2^5</span></span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">5</span>) - hash + c;     </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JDK1-8以后的HashMap在链表长度过长时会转换为红黑树，对此你怎么看？"><a href="#JDK1-8以后的HashMap在链表长度过长时会转换为红黑树，对此你怎么看？" class="headerlink" title="JDK1.8以后的HashMap在链表长度过长时会转换为红黑树，对此你怎么看？"></a>JDK1.8以后的HashMap在链表长度过长时会转换为红黑树，对此你怎么看？</h1><p>正常情况下就算数据量比较大，发生hash冲突的情况其实也不多，形成的链表长度也不会很长，有这么一个操作的话只是因为防患于未然，因为有些恶意用户可能会故意制造哈希冲突进行攻击，导致服务器变慢，所以转换为红黑树只是一个防患于未然的操作。</p>
<h1 id="cookie和Session"><a href="#cookie和Session" class="headerlink" title="cookie和Session"></a>cookie和Session</h1><p>cookie是存放在客户端浏览器上的钥匙，session是存放在服务端服务器上的保险箱。钥匙就是JsessionId，由于cookie可以设置path参数（代表在向哪个URL发起请求时会无条件的携带此Cookie），所以再向后端发起请求时，cookie随着请求头携带至后端。然后通过钥匙（JsessionId）“打开”后端服务器上的保险箱（session），获取到用户信息。</p>
<h1 id="String的常用方法"><a href="#String的常用方法" class="headerlink" title="String的常用方法"></a>String的常用方法</h1><p><strong>String.format</strong></p>
<ul>
<li>格式化字符串</li>
</ul>
<p><strong>String.replace</strong></p>
<ul>
<li>替换字符串，返回一个新的字符串，因为String是不可变的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">original</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">replaced</span> <span class="operator">=</span> original.replace(<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;X&#x27;</span>);</span><br><span class="line"><span class="comment">// 结果为 &quot;HellX WXrld&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>String.subString</strong></p>
<ul>
<li>截取对应索引之后的字符串</li>
</ul>
<p><strong>String.indexOf</strong></p>
<ul>
<li>返回对应字符所在的索引位置。</li>
</ul>
<h1 id="1、什么是session共享"><a href="#1、什么是session共享" class="headerlink" title="1、什么是session共享"></a>1、什么是session共享</h1><p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697015929631-4feb300a-4234-47ea-9538-dc07a7a0d5cd.png" alt="img"></p>
<p>因为session只能存在一台服务器上，在集群状态下，当我们有多个服务器时，每个服务器都有自己的session空间。用户请求到了别的服务器进行登陆时将造成获取不到保存在单个服务器session里的用户信息，所以这时候就需要一个共享存储。 将session存入redis后，无论用户请求哪个服务器都不影响session的识别了</p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697017752979-0897a094-5613-42d8-9614-10e0214887f5.png" alt="img"></p>
<h3 id="为什么要使用redis来存"><a href="#为什么要使用redis来存" class="headerlink" title="为什么要使用redis来存?"></a>为什么要使用redis来存?</h3><p>答： <strong>因为redis基于内存，， 比起存在硬盘里的数据库来说读写性能高出很多倍</strong></p>
<h2 id="2、什么是缓存？"><a href="#2、什么是缓存？" class="headerlink" title="2、什么是缓存？"></a>2、什么是缓存？</h2><h3 id="缓存概念"><a href="#缓存概念" class="headerlink" title="缓存概念"></a><strong>缓存概念</strong></h3><p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697022880845-11db5557-6465-4802-8ba8-98e45f552275.png" alt="img"></p>
<h3 id="为什么需要缓存？"><a href="#为什么需要缓存？" class="headerlink" title="为什么需要缓存？"></a>为什么需要缓存？</h3><p>数据量大，查询的时候太慢了，查询时首先会去查数据库，而数据库本身又会去做数据的磁盘读写，效率太低查询速度太慢，会给用户一个不好的体验，可以先把那些需要频繁查询的数据查出来，放到缓存里，这样查询速度就会快很多，优化了用户体验。</p>
<h2 id="3、缓存的作用"><a href="#3、缓存的作用" class="headerlink" title="3、缓存的作用"></a>3、缓存的作用</h2><ul>
<li>降低后端负载</li>
<li>提高读写效率，降低响应时间</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据库数据和缓存内数据可能不一致。如果数据库里更新了数据，而缓存里未及时更新数据，那么用户可能就会读到旧的数据。</li>
<li>增加代码维护成本。</li>
</ul>
<h2 id="4、添加Redis缓存的流程"><a href="#4、添加Redis缓存的流程" class="headerlink" title="4、添加Redis缓存的流程"></a>4、添加Redis缓存的流程</h2><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697024089489-7d1f0f3e-79ae-4ffe-805e-c28e153eb3f5.png" alt="img" style="zoom:50%;" />

<p>5、Redis的缓存更新策略（替换掉旧数据）</p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697027209641-56558b8f-61fd-4f14-8c27-7a1a04e460e8.png" alt="img"></p>
<p>TODO –&gt;  进行更新操作时，先查询数据库，在删除缓存 </p>
<h2 id="5、缓存穿透"><a href="#5、缓存穿透" class="headerlink" title="5、缓存穿透"></a>5、缓存穿透</h2><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>用户请求的数据在缓存和数据库中都不存在,用户每次请求数据都需要查询数据库，导致对后台数据库的频繁访问，数据库负载压力增大，这种现象就叫做缓存穿透。</p>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697031741227-59b5e300-0f31-48ff-b4a3-3f32934d8cfd.png" alt="img" style="zoom:50%;" />

<h4 id="解决方案（为了减少访问数据库的次数，降低请求压力）"><a href="#解决方案（为了减少访问数据库的次数，降低请求压力）" class="headerlink" title="解决方案（为了减少访问数据库的次数，降低请求压力）"></a>解决方案（为了减少访问数据库的次数，降低请求压力）</h4><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697033094835-7489d550-3045-4087-8f2e-2b67a90af91e.png" alt="img" style="zoom:50%;" />

<h5 id="1-缓存空对象（一般选择这种方式）"><a href="#1-缓存空对象（一般选择这种方式）" class="headerlink" title="1. 缓存空对象（一般选择这种方式）"></a>1. 缓存空对象（一般选择这种方式）</h5><p>当数据库中查不到数据的时候，缓存空对象，然后给这个空对象的缓存设置过期时间，下次再查询 数据的时候，直接从缓存中获取，从而达到了减小数据库压力的目的。</p>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697031867693-9de51a49-2bfe-4e89-bdcb-5828b96d8b8a.png" alt="img" style="zoom: 67%;" />

<p>优点：<strong>实现简单，维护方便</strong></p>
<p>缺点：</p>
<ul>
<li>需要缓存层提供更多的内存空间来缓存空对象,浪费更多内存空间。<strong>也就是说当有人在一直发起不存在的请求时，就会创造出一大堆垃圾占用内存空间。</strong></li>
<li>即使在缓存空对象时设置很短的过期时间，可能存在短期数据不一致问题。<strong>就是当发起一个错误ID被缓存为NULL，但这时突然数据库还真的加了一个这个ID的数据在数据库中，并且用户还去查询这个数据，但是数据却不存在。这时就出现了数据不一致问题，只能等NULL缓存 过期才可以缓存到真实的数据进去。</strong></li>
</ul>
<h5 id="2-布隆过滤"><a href="#2-布隆过滤" class="headerlink" title="2. 布隆过滤"></a>2. 布隆过滤</h5><p>原理：</p>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697032276505-26ffe573-6e41-445a-aad4-08012b8f3613.png" alt="img" style="zoom:67%;" />

<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697032476588-2957c98c-1653-4125-bc83-2f99ed107cae.png" alt="img" style="zoom:67%;" />

<h2 id="6、缓存雪崩"><a href="#6、缓存雪崩" class="headerlink" title="6、缓存雪崩"></a>6、缓存雪崩</h2><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697033266967-1e752349-358c-4b94-b7b7-e458e30ecf6e.png" alt="img" style="zoom:67%;" />

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1、给不同的key的TTL添加随机值"><a href="#1、给不同的key的TTL添加随机值" class="headerlink" title="1、给不同的key的TTL添加随机值"></a>1、给不同的key的TTL添加随机值</h4><p>如果说突然有大量的key同时失效，那就是它们的TTL同时到期了。</p>
<p><strong>例如在做缓存预热的时候，提前把数据库中的数据同时批量导入到缓存之中，他们的TTL的值是一样的，那么到时候时间一到，所有的缓存都一起过期了。这样就会出现缓存雪崩。</strong></p>
<p><strong>可以给不同的Key后边跟上一个随机数，比如1-5，那么有效期就会有5分钟的波动了，分散了这些Key的有效期 ，这样就大大减小了一起失效的可能性。</strong></p>
<h4 id="2、利用Redis集群提高服务的可用性（避免Redis宕机导致的雪崩）"><a href="#2、利用Redis集群提高服务的可用性（避免Redis宕机导致的雪崩）" class="headerlink" title="2、利用Redis集群提高服务的可用性（避免Redis宕机导致的雪崩）"></a>2、利用Redis集群提高服务的可用性（避免Redis宕机导致的雪崩）</h4><p>借助Redis集群的哨兵机制，哨兵机制可以进行一个服务的监控，比如先打点Redis集群形成主从，如果有一个Redis服务宕机，比如说主宕机了，那么哨兵就可以自动的从从机里面选一个出来取替代原来的主，这样就可以确保Redis一直能够正常的提供对外服务。而且主从还可以实现一种数据的同步，如果说主宕机了，从上面还有数据，也不会导致数据的丢失，这样就可以在很大程度上保证Redis的高可用性了。</p>
<h4 id="3、给缓存业务添加降级限流策略"><a href="#3、给缓存业务添加降级限流策略" class="headerlink" title="3、给缓存业务添加降级限流策略"></a>3、给缓存业务添加降级限流策略</h4><p>比如整个集群都挂了，机房没了。这样我们可以提前做好一些容错处理，当发现Redis出现故障时，应该及时的去做服务降级。<strong>？？？？？</strong>让它不要把请求继续压到数据库上面去。</p>
<h4 id="4、给业务添加多级缓存"><a href="#4、给业务添加多级缓存" class="headerlink" title="4、给业务添加多级缓存"></a>4、给业务添加多级缓存</h4><h2 id="7、缓存击穿"><a href="#7、缓存击穿" class="headerlink" title="7、缓存击穿"></a>7、缓存击穿</h2><p>某个热点Key因为TTL到期<strong>突然失效</strong>了</p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697034926262-06dbffc2-bf43-4b8b-9f4b-a7d83f387449.png" alt="img"></p>
<p><strong>高并发</strong>：也就是说某个Key访问次数非常非常多，有很多个线程都在访问。比如正在做活动的某一件商品，同一时刻可能有无数的请求来访问这一个Key。</p>
<p><strong>缓存重建：</strong>某个Key在Redis里存着，在某个时间就会被清除，缓存就会失效，失效时候就得从数据库里查询并写入Redis，因为重建结构复杂，时间长，在这个时间段里可能就有大量的请求访问数据库。</p>
<p>下图是所有线程都在查询都在那个时间点访问数据库。</p>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697035224037-99c4d6dd-654b-4729-9017-9748efacc8b8.png" alt="img" style="zoom:67%;" />

<h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><h6 id="1、互斥锁"><a href="#1、互斥锁" class="headerlink" title="1、互斥锁"></a>1、互斥锁</h6><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697035444061-54a03dad-187a-4fb1-89d5-9f836ddeab24.png" alt="img" style="zoom:67%;" />

<p>缺点：  可能有一大堆线程正在等待，性能就会差。</p>
<h6 id="互斥锁实现逻辑："><a href="#互斥锁实现逻辑：" class="headerlink" title="互斥锁实现逻辑："></a>互斥锁实现逻辑：</h6><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697039339489-fb00b5bd-54ba-4bb0-96f9-2022be27abda.png" alt="img" style="zoom:67%;" />

<h6 id="2、逻辑过期（不是真的过期，永不过期）"><a href="#2、逻辑过期（不是真的过期，永不过期）" class="headerlink" title="2、逻辑过期（不是真的过期，永不过期）"></a>2、逻辑过期（不是真的过期，永不过期）</h6><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697035810477-d4488e13-0dd5-4517-affb-434b16a84440.png" alt="img" style="zoom:67%;" />



<h6 id="逻辑过期实现逻辑："><a href="#逻辑过期实现逻辑：" class="headerlink" title="逻辑过期实现逻辑："></a>逻辑过期实现逻辑：</h6><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697039236961-6982f41b-9f55-4d94-8815-874167d1a34b.png" alt="img" style="zoom:67%;" />

<h5 id="两种方案的优缺点"><a href="#两种方案的优缺点" class="headerlink" title="两种方案的优缺点"></a>两种方案的优缺点</h5><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697035855823-f3cdc0a5-2c0c-49f6-8d3b-eede53480ada.png" alt="img" style="zoom: 50%;" />

<p><strong>互斥锁</strong>只会拿新数据，在新数据未拿到之前，其他线程会一直等。数据<strong>一致性，可用性差</strong> </p>
<p><strong>一致性：新旧数据的一致（同步）</strong></p>
<p><strong>逻辑过期：可用性更好，但</strong>因为要存储过期时间，会有额外的内存消耗，数据<strong>不一致</strong></p>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697036071523-975bd72a-4508-4552-9dde-8897be8dba89.png" alt="img" style="zoom: 67%;" />

<h2 id="8、分布式锁"><a href="#8、分布式锁" class="headerlink" title="8、分布式锁"></a>8、分布式锁</h2><h3 id="8-1、什么是分布式锁？"><a href="#8-1、什么是分布式锁？" class="headerlink" title="8.1、什么是分布式锁？"></a>8.1、什么是分布式锁？</h3><p>满足分布式系统或集群模式下多线程可见并且互斥的锁。</p>
<p>集群状态下，需要使用分布式锁。</p>
<p><strong>分布式锁的应用场景？</strong></p>
<p>一个jvm里多个线程可以用一个锁来控制，但是在服务器集群状态下多个jvm里都有单独的锁，这样就会有多线程并行的安全问题。这时可以使用分布式锁。</p>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697079994076-9aa38489-153a-4595-90bd-9aff8c5cce7a.png" alt="img" style="zoom:67%;" />

<p>工作原理：</p>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697080824360-3b112770-5810-493f-9af3-dce9d4b4b615.png" alt="img" style="zoom:67%;" />



<p>分布式锁的实现方式：</p>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697081234323-34c1cd59-f547-4c94-ae24-1057614129c6.png" alt="img" style="zoom:50%;" />

<h2 id="9、在MySQL中，如何定位慢查询SQL"><a href="#9、在MySQL中，如何定位慢查询SQL" class="headerlink" title="9、在MySQL中，如何定位慢查询SQL"></a>9、在MySQL中，如何定位慢查询SQL</h2><p>答：我记得可以用Skywalking查看接口的响应情况，那些访问慢的接口会排最前面，一目了然，但是这个我项目中没用过，只是说知道有这么一种方式。第二个呢是启用慢查询日志，可以设置时间为两秒什么的，然后那些执行时间超过2秒的语句就会被这个日志给记录下来，这样就可以定位到那些比较慢的查询语句了。</p>
<h2 id="10、对于执行得很慢的SQL，该如何处理？"><a href="#10、对于执行得很慢的SQL，该如何处理？" class="headerlink" title="10、对于执行得很慢的SQL，该如何处理？"></a>10、对于执行得很慢的SQL，该如何处理？</h2><p>用MySQL自带的那个分析工具explain吧。可以在select关键字前用explain和desc查看那条语句是怎么被执行的。然后再看看里面的一些重点参数如type，possible keys,keys,key len（索引占用的大小） ,extra什么的。</p>
<p>先看这个type连接类型吧，他会有一系列的参数来表明这条sql的性能，分别是… … .. ,当出现index整个索引树和all全表扫描的时候就可以考虑进行优化了。然后再看key和key len看看是否命中了索引，因为索引本身会有失效的情况，比如没有遵守最左前缀法则，或者说出现了范围查询什么的，然后再看看extra这一栏，看看有没有出现回表查询的情况，如果出现了回表查询可以进行添加索引或者修改返回字段来进行优化。</p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698761680162-2deee2bc-715a-4b29-a3bc-72c66892e11a.png" alt="img"></p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698761903038-8384e170-f82c-4d99-b58c-3006ffdf8d75.png" alt="img"></p>
<h2 id="11、如果一个数据表，只有四个字段，有两百万的数据，想要快速访问，需要建索引吗"><a href="#11、如果一个数据表，只有四个字段，有两百万的数据，想要快速访问，需要建索引吗" class="headerlink" title="11、如果一个数据表，只有四个字段，有两百万的数据，想要快速访问，需要建索引吗?"></a>11、如果一个数据表，只有四个字段，有两百万的数据，想要快速访问，需要建索引吗?</h2><p>答：我觉得的看情况，看这张表的访问频率高不高，它的查询是否频繁，它是否会严重的影响用户体验。</p>
<h2 id="12、什么是索引？"><a href="#12、什么是索引？" class="headerlink" title="12、什么是索引？"></a>12、什么是索引？</h2><ul>
<li>索引是帮助MySQL高效获取数据的一种有序数据结构。它的底层是使用到了B+树，所以说就可以实现高效的查找数据了。</li>
<li>提高数据的检索效率，降低数据库的IO成本（不需要全表扫描）</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。</li>
</ul>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698763416462-af0b601c-e3da-4436-b6b6-794971715bb9.png" alt="img"></p>
<h2 id="13、什么是聚集索引，什么是二级索引？"><a href="#13、什么是聚集索引，什么是二级索引？" class="headerlink" title="13、什么是聚集索引，什么是二级索引？"></a>13、什么是聚集索引，什么是二级索引？</h2><p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698667661086-c85a3f37-5b68-4ef0-805b-d05867481663.png" alt="img"></p>
<p><strong>知道回表查询吗？</strong></p>
<ul>
<li>先在二级索引拿到对应的ID值，再到聚集索引根据ID找到对应的行数据。</li>
</ul>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698667847300-cd048c31-25b5-4bbe-a76d-32cae140449d.png" alt="img"></p>
<h2 id="14、什么是覆盖索引？"><a href="#14、什么是覆盖索引？" class="headerlink" title="14、什么是覆盖索引？"></a>14、什么是覆盖索引？</h2><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698764082852-bd897040-193e-4da7-a1fb-606d693d9de1.png" alt="img" style="zoom:67%;" />

<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698763954248-2571be04-9ecb-4758-9bde-651ee359600f.png" alt="img" style="zoom:60%;" />

<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698763990479-3f54be68-03e1-499b-8b85-e346dc8d7ab0.png" alt="img" style="zoom:50%;" />

<h2 id="15、索引的设计关键原则有哪些？"><a href="#15、索引的设计关键原则有哪些？" class="headerlink" title="15、索引的设计关键原则有哪些？"></a>15、索引的设计关键原则有哪些？</h2><p>为何要尽量使用联合索引？</p>
<ul>
<li>避免回表查询</li>
</ul>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698764774255-8118a6a9-9033-4f18-890b-b01d32a141bc.png" alt="img" style="zoom:67%;" />

<h2 id="16、索引失效情况"><a href="#16、索引失效情况" class="headerlink" title="16、索引失效情况"></a>16、索引失效情况</h2><p>用explain看看索引到底有没有用上，如果没有用上再结合索引具体看看sql语句哪里出了问题。</p>
<ol>
<li><strong>违反了最左前缀法则</strong></li>
</ol>
<ul>
<li>查询必须包含最左边的列（最左边的位置跟在不在最左边无关，只要有就行）否则不会使用索引</li>
<li><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698704821918-c21e10a8-0203-4233-9803-be3a9231850c.png" alt="img"></li>
</ul>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698704024063-8c469f02-7d17-45b5-bc1c-41deef3075fc.png" alt="img"></p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698704284011-be1776c6-e93d-4fe6-aec5-bc7ee3b4c202.png" alt="img"><strong>三个字段连查，中间并未跳过某一个字段，这时会执行索引。最左边是pro</strong></p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698704278655-670cd07e-bad6-4b18-bd35-689e976c7e02.png" alt="img"></p>
<p><strong>省略了最左边的字段，没有遵守最左前缀法则，没有执行索引，使用了全表 扫描</strong></p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698704466266-3c72cb2a-ce01-41d3-b47b-6d1fc4169cb6.png" alt="img"></p>
<p>中间字段被跳过，后面索引失效。</p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698704645614-4287aae0-2340-4b8b-88c7-eecb03c9863f.png" alt="img"></p>
<ol>
<li><strong>使用到了范围查询</strong></li>
</ol>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698704877006-cecd2191-d1da-457d-b651-524c3d6ffbcb.png" alt="img"></p>
<ul>
<li><p>解决方案</p>
</li>
<li><p>尽量使用&gt;&#x3D;  . &lt;&#x3D;</p>
</li>
</ul>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698705044945-437c3255-3160-4d7b-9f7c-d3c31a228996.png" alt="img"></p>
<p>status失效。</p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698705579719-a13925de-7ab3-451d-b16e-53c271ea3d85.png" alt="img"></p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698705605749-3d329ad3-4dad-433c-b532-525322d9eddb.png" alt="img">失效</p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698705595345-72fcb6eb-788b-4ffa-aa07-df2dc3739e1d.png" alt="img"></p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698705638844-ede35a2b-14e2-459e-9f65-a930ea1c07bc.png" alt="img"></p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698705740401-9088e434-bf67-4c3e-9308-df599af2730a.png" alt="img"></p>
<p>status索引失效，age成功</p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698705782225-43600a11-77e1-45ef-a51f-8e4efdb4dc6f.png" alt="img"></p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698705905023-65dda50e-9d32-4105-a010-a3f7a0e473ca.png" alt="img">成功使用索引。</p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698705914662-dd1b8c10-49c7-47f9-809d-76df9212a63e.png" alt="img">不走索引。</p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698706094484-91dfd0be-06b5-48f4-abe7-3929170a87cc.png" alt="img"></p>
<p>id phone有索引，但是后面的没有，所以所涉及到的索引都不会被用到。</p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698706304942-9f4c1f00-e98f-4553-8497-88fbac35eca8.png" alt="img"></p>
<p>比如本来就是直接走全表扫描的查询，就没必要用到索引了。</p>
<h2 id="17、谈谈你对SQL优化的经验。"><a href="#17、谈谈你对SQL优化的经验。" class="headerlink" title="17、谈谈你对SQL优化的经验。"></a>17、谈谈你对SQL优化的经验。</h2><ul>
<li>如果有重复值的情况，union会将重复值给过滤掉，效率低。</li>
<li>在where子句中对字段进行表达式操作可能会导致索引失效。</li>
<li><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698766440144-0655b107-0a6e-4c94-9575-bfa46d07c34f.png" alt="img"></li>
</ul>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698765931184-f908017e-c3c2-4019-a5ae-cac14fc99464.png" alt="img"></p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698766402874-97dc5d50-1993-4f37-9ff2-2224d9d0b5e3.png" alt="img"></p>
<h2 id="18、事务"><a href="#18、事务" class="headerlink" title="18、事务"></a>18、事务</h2><p><strong>MySQL是自动提交事务的。</strong></p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698652144645-5354c684-2a64-4808-af47-f1db34a85502.png" alt="img"></p>
<h3 id="1、四大特性是什么？"><a href="#1、四大特性是什么？" class="headerlink" title="1、四大特性是什么？"></a>1、四大特性是什么？</h3><ul>
<li>一致性，就是转账的时候，a转了1000，b就必须增加1000</li>
</ul>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698654187149-af0bd20d-86a8-4a74-a6ac-14c6cc421fe5.png" alt="img"></p>
<h3 id="2、并发事务引发的问题"><a href="#2、并发事务引发的问题" class="headerlink" title="2、并发事务引发的问题"></a>2、并发事务引发的问题</h3><p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698654579631-3a70f532-a7d3-4777-8791-9530916a31cc.png" alt="img"></p>
<ul>
<li><strong>脏读，A更新了a数据，但是没有提交，此时未提交的a数据被B读到了</strong></li>
</ul>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698654700718-43888213-d498-47b3-84ef-657b1d1a0eca.png" alt="img"></p>
<ul>
<li><strong>不可重复读，A先读取一个a数据，然后B事务更新了a数据，A又再读取a数据，此时发现a数据不一样了。解决此问题后两次读取的数据就会是一致的，跟第一次读到的保持一致。</strong></li>
</ul>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698654606140-98f91551-397a-4484-a6ff-40423fdfaa42.png" alt="img"></p>
<ul>
<li><strong>幻读</strong></li>
</ul>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698654975834-6a9046b2-f8e5-4ce2-a9db-cccae73c8582.png" alt="img"></p>
<h3 id="3、事务隔离级别"><a href="#3、事务隔离级别" class="headerlink" title="3、事务隔离级别"></a>3、事务隔离级别</h3><ul>
<li>性能由上到下越来越差</li>
<li>SESSION仅仅针对当前客户端窗口有效</li>
<li>GLOBAL针对所有客户端的窗口有效</li>
</ul>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698655163110-523db7f1-04dd-4072-904b-f2511b5f8972.png" alt="img"></p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698655338846-e3359e55-0fa7-435c-a42f-38826931c3f7.png" alt="img">、</p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698766743207-41bab017-5e67-44e3-8e23-6546dba11107.png" alt="img"></p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698766931270-222f408b-aed5-4f5a-a645-48a76125ba26.png" alt="img"></p>
<h3 id="4、undo-log和redo-logo"><a href="#4、undo-log和redo-logo" class="headerlink" title="4、undo log和redo logo"></a>4、undo log和redo logo</h3><h3 id="5、解释一下mvcc"><a href="#5、解释一下mvcc" class="headerlink" title="5、解释一下mvcc"></a>5、解释一下mvcc</h3><h2 id="19、主从同步原理"><a href="#19、主从同步原理" class="headerlink" title="19、主从同步原理"></a>19、主从同步原理</h2><h2 id="20、分库分表"><a href="#20、分库分表" class="headerlink" title="20、分库分表"></a>20、分库分表</h2><h2 id="21、（双写一致性）redis作为缓存，mysql的数据如何与redis进行同步呢"><a href="#21、（双写一致性）redis作为缓存，mysql的数据如何与redis进行同步呢" class="headerlink" title="21、（双写一致性）redis作为缓存，mysql的数据如何与redis进行同步呢"></a>21、（双写一致性）redis作为缓存，mysql的数据如何与redis进行同步呢</h2><h2 id="22、redis的持久化是怎么做的？"><a href="#22、redis的持久化是怎么做的？" class="headerlink" title="22、redis的持久化是怎么做的？"></a>22、redis的持久化是怎么做的？</h2><h2 id="23、spring框架中的单例bean是线程安全的吗？"><a href="#23、spring框架中的单例bean是线程安全的吗？" class="headerlink" title="23、spring框架中的单例bean是线程安全的吗？"></a>23、spring框架中的单例bean是线程安全的吗？</h2><ul>
<li>无状态Bean   —不能被修改的Bean</li>
</ul>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698768846754-b9f98e90-de99-41b6-80d7-4b8acaa67059.png" alt="img" style="zoom:80%;" />

<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698768792778-475f5b58-b723-4280-b893-d28d7f95a7f9.png" alt="img"></p>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698768835042-de7411fa-aa59-4cb4-a15a-ee5d3113998a.png" alt="img" style="zoom:80%;" />



<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698768762510-88b4cc6e-fe8b-442a-97ba-97893f0ca1f0.png" alt="img" style="zoom:80%;" />

<h2 id="24、Spring框架常见注解"><a href="#24、Spring框架常见注解" class="headerlink" title="24、Spring框架常见注解"></a>24、Spring框架常见注解</h2><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698769102349-45654d47-f752-496e-b384-02121bf90f25.png" alt="img" style="zoom:80%;" />

<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698769118622-a7c5d612-1e46-4381-ae61-cd666e2f5929.png" alt="img" style="zoom:80%;" />

<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698769142850-144df6c8-1e44-4609-a001-7f61abf99453.png" alt="img" style="zoom:80%;" />

<h2 id="25、Springboot自动配置原理"><a href="#25、Springboot自动配置原理" class="headerlink" title="25、Springboot自动配置原理"></a>25、Springboot自动配置原理</h2><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698769290612-7028f36b-e208-45dc-866e-566c9fe5f043.png" alt="img" style="zoom:80%;" />

<h2 id="26、bean的生命周期"><a href="#26、bean的生命周期" class="headerlink" title="26、bean的生命周期"></a>26、bean的生命周期</h2><h2 id="27、事务失效的场景"><a href="#27、事务失效的场景" class="headerlink" title="27、事务失效的场景"></a>27、事务失效的场景</h2><h3 id="1、异常捕获处理但不抛出"><a href="#1、异常捕获处理但不抛出" class="headerlink" title="1、异常捕获处理但不抛出"></a>1、异常捕获处理但不抛出</h3><ul>
<li><p><strong>理论上出现异常那么事务就会回滚，但是如果把这个异常try catch捕获但不抛出就可能导致事务失效。</strong></p>
</li>
<li><p><strong>原因：事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉。</strong></p>
</li>
<li><p><strong>解决方法</strong></p>
</li>
<li><p><strong>在Catch块中添加throw new RuntimeException(“失败”)抛出，也就是捕获了异常并将异常抛出。</strong></p>
</li>
<li><p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698890813036-221addb0-277e-40e9-bcdc-ca6f749cec82.png" alt="img"></p>
</li>
<li><p>失败情况：</p>
</li>
</ul>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698889845105-c2551f78-6fa5-4a06-9f82-032934348ba7.png" alt="img" style="zoom:80%;" />

<h3 id="2、抛出编译时异常"><a href="#2、抛出编译时异常" class="headerlink" title="2、抛出编译时异常"></a>2、抛出编译时异常</h3><ul>
<li><p><strong>原因</strong></p>
</li>
<li><p><strong>Spring默认只会回滚运行时异常。</strong></p>
</li>
<li><p>解决方式</p>
</li>
<li><p>配置rollbackFor属性</p>
</li>
<li><p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698891102767-d7e8c700-ac1e-451b-99b8-8a81b2843bfc.png" alt="img">–&gt;一旦有异常，不管是什么都会回滚。</p>
</li>
</ul>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698891037579-aaeafa8d-1ec2-4ba7-9417-b90e8ec8c110.png" alt="img" style="zoom:80%;" />

<h3 id="3、非public方法导致的事务失效"><a href="#3、非public方法导致的事务失效" class="headerlink" title="3、非public方法导致的事务失效"></a>3、非public方法导致的事务失效</h3><ul>
<li><p><strong>原因：也就是方法并没有加public修饰符修饰，Spring为方法创建代理、添加事务通知、前提条件都是该方法是public的</strong></p>
</li>
<li><p><strong>解决方法</strong></p>
</li>
<li><p><strong>添加public</strong></p>
</li>
</ul>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698891189792-5695b25f-bb48-4ae3-a332-7a599cfe1751.png" alt="img" style="zoom:80%;" />

<h3 id="4、数据库不支持事务"><a href="#4、数据库不支持事务" class="headerlink" title="4、数据库不支持事务"></a>4、数据库不支持事务</h3><h2 id="28、线程和进程的区别"><a href="#28、线程和进程的区别" class="headerlink" title="28、线程和进程的区别"></a>28、线程和进程的区别</h2><ol>
<li><p><strong>进程</strong></p>
</li>
<li><p>指运行中的程序。是程序的一次执行过程，或是正在运行的一个程序。是动态过程，有它自身的产生、存在、消亡过程。</p>
</li>
<li><p>当一个程序被运行，从磁盘加载这个程序的代码到内存，这时就开启了一个进程。</p>
</li>
<li><p>进程可以视为程序的一个实例，大部分程序可以同时运行多个实例进程如（记事本，画图，浏览器），也有的程序，也有的程序只能启动一个实例进程（网易云音乐）</p>
</li>
<li><p><strong>线程</strong></p>
</li>
<li><p>一个进程可以分为一到多个线程。</p>
</li>
<li><p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行。</p>
</li>
<li><p>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作 为线程的容器</p>
</li>
</ol>
<p><strong>两者对比：</strong></p>
<ul>
<li><p>进程基本上是相互独立的，而线程存在于进程内，是进程的一个子集  </p>
</li>
<li><p>进程拥有共享的资源，如内存空间等，供其内部的线程共享  </p>
</li>
<li><p>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</p>
</li>
<li><p>进程间通信较为复杂  </p>
</li>
<li><p>同一台计算机的进程通信称为 IPC（Inter-process communication）  </p>
</li>
<li><p>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP  </p>
</li>
<li><p>不同进程使用不同的内存空间，在当前进程下的线程可以共享内存空间</p>
</li>
<li><p>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量  </p>
</li>
<li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低  （指从一个线程切换到另一个线程）</p>
</li>
</ul>
<h2 id="29、并行与并发的区别"><a href="#29、并行与并发的区别" class="headerlink" title="29、并行与并发的区别"></a>29、并行与并发的区别</h2><ol>
<li><strong>并发</strong></li>
</ol>
<ul>
<li><strong>单核 cpu 下，线程实际还是串行执行的</strong>。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows 下时间片最小约为 15 毫秒）分给不同的程序使用（每个线程用15毫秒），只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感 觉是 同时运行的 。总结为一句话就是： 微观串行，宏观并行 ， 一<strong>般会将这种线程轮流使用 CPU 的做法称为并发</strong></li>
</ul>
<ol>
<li><strong>并行</strong></li>
</ol>
<ul>
<li><strong>多核 cpu下，每个 核（core） 都可以调度运行线程，这时候线程可以是并行的。</strong>  如果两核CPU，10个线程，那么可以并行并发同时存在。同时有两个线程在执行（并行），但有10个进程在交替着执行（并发）。</li>
</ul>
<p><strong>总结</strong></p>
<p> <strong>并发是同一时间应对多件事情的能力 并行是同一时间动手做多件事情的能力</strong>  </p>
<h2 id="30、创建线程的方式"><a href="#30、创建线程的方式" class="headerlink" title="30、创建线程的方式"></a>30、创建线程的方式</h2><ol>
<li><strong>继承Thread类，重写run方法</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 构造方法的参数是给线程指定名字，推荐 //利用匿名内部类的一个方式创建了一个线程对象。 //如果直接T1.run  这是Main线程在执行run方法，并不是子线程在执行。 Thread t1 = new Thread(&quot;t1&quot;) &#123; @Override // run 方法内实现了要执行的任务 public void run() &#123; log.debug(&quot;hello&quot;);     Thread.sleep(1000) //让线程休眠1S &#125; &#125;; //启动线程，交给操作系统的任务调度器，让它分配时间片，得到时间片CPU就会执行这个线程 t1.start();</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>实现Runnable接口，重写run方法。</strong></li>
</ol>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697628042747-9a37b3c5-6d75-48bd-bc98-f1843510b2b1.png" alt="img"></p>
<ul>
<li><strong>Thread 代表线程</strong> </li>
<li><strong>Runnable 可运行的任务（线程要执行的代码）</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>实现Callable接口 todo</strong></li>
<li><strong>线程池创建线程 todo</strong></li>
</ol>
<h2 id="31、线程包含了哪些状态"><a href="#31、线程包含了哪些状态" class="headerlink" title="31、线程包含了哪些状态"></a>31、线程包含了哪些状态</h2><p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1697647082183-3d206b28-6f53-4c26-9748-e64793872e65.png" alt="img"></p>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698893007658-f4525a06-885c-49db-b6d1-b6f4ae5161a5.png" alt="img" style="zoom:80%;" />

<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698893048525-238d43fa-18c6-4240-9dea-0ecdd377e8a6.png" alt="img" style="zoom:80%;" />

<h2 id="32、有三个线程，如何让他们顺序执行？"><a href="#32、有三个线程，如何让他们顺序执行？" class="headerlink" title="32、有三个线程，如何让他们顺序执行？"></a>32、有三个线程，如何让他们顺序执行？</h2><ul>
<li>join方法让t2进入阻塞状态，只有t1运行完成，t2才能开始</li>
</ul>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698893209557-4c91aba8-69df-443f-81d8-ab8e29c9db2f.png" alt="img" style="zoom:80%;" />

<h2 id="33、notify-和notifyAll-有什么区别？"><a href="#33、notify-和notifyAll-有什么区别？" class="headerlink" title="33、notify()和notifyAll()有什么区别？"></a>33、notify()和notifyAll()有什么区别？</h2><p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698893318834-a4fc034e-4568-4a72-88b2-22c31f3ab1c5.png" alt="img"></p>
<p>wait notifyall notify三个方法都必须得进入房间了才可以调用。三者都是obj的方法，sleep是线程的方法。</p>
<h2 id="34、wait和sleep方法的不同？"><a href="#34、wait和sleep方法的不同？" class="headerlink" title="34、wait和sleep方法的不同？"></a>34、wait和sleep方法的不同？</h2><p><strong>wait</strong></p>
<ul>
<li><strong>我去等待室了（放下锁）  直到被下一个线程唤醒–&gt; 回到阻塞队列等待运行</strong></li>
</ul>
<p><strong>sleep</strong></p>
<p><strong>如果在Synchronized中执行，直接原地睡觉，（不释放锁） 直到被下一个线程唤醒</strong></p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698942313181-1638a17d-27a7-4224-afdb-3ad87f2f3345.png" alt="img"></p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698893551817-37a1fd83-f4e5-49b6-aacf-efdf1ecb4fdc.png" alt="img"></p>
<h2 id="35、Synchronized底层原理"><a href="#35、Synchronized底层原理" class="headerlink" title="35、Synchronized底层原理"></a>35、<strong>Synchronized底层原理</strong></h2><h2 id="36、说一下线程池的核心参数"><a href="#36、说一下线程池的核心参数" class="headerlink" title="36、说一下线程池的核心参数"></a>36、说一下线程池的核心参数</h2><p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698954059223-c367517b-ccf7-46c8-8f75-f6a204864260.png" alt="img"></p>
<ul>
<li><p><strong>corePoolSize 核心线程数</strong></p>
</li>
<li><p>线程池中主要执行任务的最小线程数</p>
</li>
<li><p><strong>maximumPoolSize 最大线程数</strong></p>
</li>
<li><p>等于核心线程数+临时线程数的最大数目</p>
</li>
<li><p><strong>keepAliveTime  临时线程空闲时最大存活时间</strong></p>
</li>
<li><p>非核心线程在闲置状态的最大存活时间 </p>
</li>
<li><p><strong>unit 时间单位</strong></p>
</li>
<li><p>临时线程的生存时间</p>
</li>
<li><p><strong>workQueue   阻塞队列</strong></p>
</li>
<li><p>用于存放等待执行的任务，当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建临时线程执行任务</p>
</li>
<li><p><strong>ThreadFactory 线程工厂</strong></p>
</li>
<li><p>可以定制线程对象的创建，例如设置线程名字，是否时守护线程等</p>
</li>
<li><p><strong>handler 拒绝策略</strong></p>
</li>
<li><p>当所有线程都在繁忙，workQueue也放满时，会触发拒绝策略</p>
</li>
</ul>
<h2 id="37、线程池的执行原理"><a href="#37、线程池的执行原理" class="headerlink" title="37、线程池的执行原理"></a>37、线程池的执行原理</h2><p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698954230560-db86b5b7-f902-4f7b-82ff-16860c2ed16d.png" alt="img"></p>
<h2 id="38、如何合理的设置核心线程数？"><a href="#38、如何合理的设置核心线程数？" class="headerlink" title="38、如何合理的设置核心线程数？"></a>38、如何合理的设置核心线程数？</h2><p>我项目是IO密集型，所以设置的是32，我CPU核心数是16.也就是CPU核数的两倍。</p>
<p>如果是计算密集型的话，那就设置为跟CPU核数一致或者加1就差不多了。</p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698955368095-bb326099-20c1-49a1-a7b2-6541d66a46a8.png" alt="img"></p>
<h2 id="39、分布式锁的应用场景"><a href="#39、分布式锁的应用场景" class="headerlink" title="39、分布式锁的应用场景"></a>39、分布式锁的应用场景</h2><p><strong>分布式锁是一种用于控制分布式系统中多个节点之间对共享资源的访问的技术。它可以确保在任何给定时刻只有一个节点能够访问共享资源，从而避免竞态条件和数据不一致性问题。</strong>	</p>
<ul>
<li>集群情况下的定时任务、幂等性、抢单。</li>
</ul>
<p><strong>定时任务</strong></p>
<p>在使用定时任务进行缓存预热时，假如我们同一份代码是部署在多个机器上，如果说0点到了，该更新缓存了，那难道我们每个机器都要去执行一次这个任务吗？这个时候就可以用到分布式锁，控制同一时间只有一台机器去执行定时任务，其他机器就不用重复执行了。</p>
<p><strong>抢票</strong></p>
<p>总共只有五张票，假如说同时有五个用户分别请求了不同的机器，然后这些机器先去查这个票数，发现查询时确实是有五张票，然后这五个用户每人都买五张票，那最后肯定是有人买不到的，这时就需要用分布式锁控制一下，这时就只能是一个服务器访问一个共享资源，而不是说所有的用户集中查这个库存，以保证每次读票查票的时候都是一个最新的状态。</p>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698993934040-efb39281-4bcf-4053-aa68-0f6ca209fcb5.png" alt="img" style="zoom:80%;" />

<h2 id="40、分布式锁的实现原理"><a href="#40、分布式锁的实现原理" class="headerlink" title="40、分布式锁的实现原理"></a>40、分布式锁的实现原理</h2><ul>
<li>redis实现分布式锁主要利用setnx命令：setnx: set if not exists 如果Key不存在，则设置;只有设置成功才会返回 true，否则返回 false。  </li>
<li>若不设置过期时间，则会导致死锁发生</li>
<li>不可重入锁</li>
</ul>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698994224645-1aab8237-a4dd-4822-b345-31d2f8d2fa52.png" alt="img"></p>
<p>键lock \  值 value  \NX 只有键不存在才设置 \  EX 10  过期时间10.</p>
<h3 id="1、如何合理的控制锁过期的时间？"><a href="#1、如何合理的控制锁过期的时间？" class="headerlink" title="1、如何合理的控制锁过期的时间？"></a>1、如何合理的控制锁过期的时间？</h3><p>进行续期</p>
<h3 id="2、Redisson实现分布式锁的原理（可重入锁）"><a href="#2、Redisson实现分布式锁的原理（可重入锁）" class="headerlink" title="2、Redisson实现分布式锁的原理（可重入锁）"></a>2、Redisson实现分布式锁的原理（可重入锁）</h3><p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698995666018-7f4335bc-bff8-49b0-9caf-9400d3be56c4.png" alt="img"></p>
<p><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1698995395245-1d4ef228-3690-4130-af5b-2610ad6474bb.png" alt="img"></p>
<h2 id="41、redisson-实现分布式锁的底层为什么要用setnx和lua？它们两者分别起到了什么作用？"><a href="#41、redisson-实现分布式锁的底层为什么要用setnx和lua？它们两者分别起到了什么作用？" class="headerlink" title="41、redisson 实现分布式锁的底层为什么要用setnx和lua？它们两者分别起到了什么作用？"></a>41、redisson 实现分布式锁的底层为什么要用setnx和lua？它们两者分别起到了什么作用？</h2><ol>
<li><strong>setnx</strong> <strong>(SET if Not eXists):</strong></li>
</ol>
<ul>
<li>作用：<strong>setnx</strong> 是 Redis 提供的命令，用于在键不存在时设置键的值。它是分布式锁的基础原语之一。</li>
<li>实现：Redisson使用 <strong>setnx</strong> 命令来尝试获取锁，如果锁不存在，它将成功获取锁，并将锁的持有者设置为当前客户端的标识。这是通过设置键的方式来表示锁的拥有情况。</li>
<li>特点：<strong>setnx</strong> 是原子操作，只有在锁不存在的情况下才能设置成功。这保证了只有一个客户端能够成功获取锁。</li>
</ul>
<ol>
<li><strong>Lua 脚本：</strong></li>
</ol>
<ul>
<li>作用：Lua 脚本用于实现更复杂的分布式锁逻辑，例如锁的续约、锁的释放等。</li>
<li>实现：Redisson使用 Lua 脚本来实现诸如锁的续约（refresh）、锁的释放（release）等操作。Lua 脚本允许在单个原子事务中执行多个 Redis 命令，从而确保这些操作的原子性。</li>
<li>特点：Lua 脚本可以实现分布式锁的高级功能，例如自动续约锁以防止过期，以及安全的释放锁。这有助于提高锁的可用性和安全性。</li>
</ul>
<p>综合使用 <strong>setnx</strong> 和 Lua 脚本的方法，Redisson实现了一个完整的分布式锁系统，包括锁的获取、续约和释放。<strong>setnx</strong> 用于基本的锁获取，而 Lua 脚本用于处理更复杂的锁操作，以确保锁的一致性和可靠性。这种结合使用的方式充分发挥了 Redis 的原子性操作和 Lua 脚本的优势，使分布式锁的实现更加可靠和功能丰富。</p>
<h2 id="42、TCP的三次握手机制"><a href="#42、TCP的三次握手机制" class="headerlink" title="42、TCP的三次握手机制"></a>42、TCP的三次握手机制</h2><p><strong>男：喂，听得到吗？</strong>**<br><strong><strong>女：听得到，你听得到吗？</strong></strong><br><strong><strong>男：我也听得到</strong></strong><br><strong><strong>建立连接</strong></strong>🤝**</p>
<p>首先，三次握手的机制是为了保证能建立一个安全可靠的连接，那么第一次握手是由客户端发起，客户端会向服务端发送一个报文，在报文里面：SYN标志位置为1，表示发起新的连接。第二次握手是有服务端向客户端发起，当服务端收到这个报文之后就知道客户端要和我建立一个新的连接，于是服务端就向客户端发送一个确认消息包，在这个消息包里面：ack标志位设置为1，表示确认客户端发起的第一次连接请求。以上两次握手之后，对于客户端而言：已经明确了我既能给服务端成功发消息，也能成功收到服务端的响应。但是对于服务端而言：两次握手是不够的，因为到目前为止，服务端只知道一件事，客户端发给我的消息我能收到，但是我响应给客户端的消息，客户端能不能收到我是不知道的。所以，还需要进行第三次握手，第三次握手就是当客户端收到服务端发送的确认响应报文之后，还要继续去给服务端进行回应，也是一个ack标志位设置为1的确认消息。通过以上三次连接，不管是客户端还是服务端，都知道我既能给对方发送消息，也能收到对方的响应。那么，这个连接就被安全的建立了。</p>
<p><strong>TCP提供面向连接的可靠服务，因此在数据传送之前必须要先建立连接，TCP 连接是通过三次握手建立的。</strong></p>
<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1696614013167-eb741739-de4e-4f8a-84ce-3eed1be4b580.png" alt="img" style="zoom: 50%;" />



<p><strong>三次握手的过程：</strong></p>
<ul>
<li><p>最开始，客户端和服务端都处于<strong>CLOSE状态</strong>，先是服务端监听客户端的请求，进入<strong>LISTEN状态</strong></p>
</li>
<li><p>客户端发送连接请求，<strong>第一次握手</strong> (SYN&#x3D;1(建立新连接), seq&#x3D;x（序列号为x）)，发送完毕后，客户端就进入 SYN_SENT 状态</p>
</li>
<li><p>服务端确认连接，<strong>第二次握手</strong> (SYN&#x3D;1, ACK&#x3D;1（确认接收）, seq&#x3D;y, ACKnum&#x3D;x+1)， 发送完毕后，服务器端就进入 SYN_RCV 状态。</p>
</li>
<li><p>客户端收到服务端的确认之后，再次向服务端确认，这就是<strong>第三次握手</strong> (ACK&#x3D;1，ACKnum&#x3D;y+1)，发送完毕后，客户端进入 <strong>ESTABLISHED</strong> 状态，当服务器端接收到这个包时，也进入 <strong>ESTABLISHED 状态</strong>。</p>
</li>
<li><p>“SYN&#x3D;1, seq&#x3D;x” 的意思是发送一个带有SYN标志位为1的TCP数据包，用于建立新的TCP连接，并且设置该数据包的序列号为”x”</p>
</li>
<li><p>“ACKnum&#x3D;x+1” 是在接收方发送的TCP数据包中的一个字段，用于通知发送方它已经成功接收到序列号为 “x” 的数据包，并期望接收下一个序列号为 “x+1” 的数据包。</p>
</li>
<li><p>“ESTABLISHED” 是TCP连接的一个状态，表示双方已经成功建立连接，可以进行双向数据传输。<img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/Picture/1696614253389-b124b2fd-97e7-45f3-9bbd-8a4b909f1c84.png" alt="img" style="zoom:50%;" /></p>
</li>
</ul>
<h2 id="43、TCP四次挥手"><a href="#43、TCP四次挥手" class="headerlink" title="43、TCP四次挥手"></a>43、TCP四次挥手</h2><p><strong>四次挥手</strong>**<br><strong><strong>男：什么时候分</strong></strong><br><strong><strong>女：现在还不行，等下吧</strong></strong><br><strong><strong>男方继续听女方balabala</strong></strong><br><strong><strong>女：可以分了</strong></strong><br><strong><strong>男：我知道了，发吧</strong></strong><br>**<strong>电话挂断</strong></p>
<p>四次握手机制呢，通常是由客户端首先发起的，客户端会发起一个报文，在报文里面FIN标志位置1；当服务端收到这报文之后，就知道了客户端想要和我断开连接，但是此时服务端不一定能做好准备，因为当客户端发起断开连接的时候，对于服务端而言它极有可能有未发送完的的消息，它还要继续发送；所以此时对于服务端而言他只能进行一个消息确认，我先告诉服务端，我知道你要和我断开连接了，但是我这还可能没有做好准备，你还需要等我一下，等会我会告诉你；于是，发完这个消息确认包后，可能稍作片刻，它可能会继续发送一个断开连接的报文，一个FIN标志位为1的报文，是由服务端发给客户端的，这个报文表示了服务端已经做好了断开连接的准备，那么当这个报文发给客户端的时候，客户端同样要给服务端继续发送一个消息确认的报文。一共有四次，通过这四次的相互沟通和连接，我就知道了，不管是服务端还是客户端都已经做好了断开连接的准备，于是连接就可以被断开了。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://changettto.github.io">Pn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://changettto.github.io/2023/12/07/java%E9%9D%A2%E8%AF%95%E9%A2%98/">https://changettto.github.io/2023/12/07/java%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://changettto.github.io" target="_blank">Rxbby</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="https://rxbby.oss-cn-guangzhou.aliyuncs.com/HuiYuan.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/11/Axios%E7%9A%84%E5%B0%81%E8%A3%85/" title="Axios的封装"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Axios的封装</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/30/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="java多线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java多线程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/01/10/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AASDK/" title="如何开发一个SDK"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-10</div><div class="title">如何开发一个SDK</div></div></a></div><div><a href="/2023/11/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/" title="函数式接口"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-10</div><div class="title">函数式接口</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://rxbby.oss-cn-guangzhou.aliyuncs.com/HuiYuan.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Pn</div><div class="author-info__description">不努力，枉年轻！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ChangeTTTO?tab=repositories"><i class="fab fa-github"></i><span>GitHub</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">写写笔记和日常</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#String"><span class="toc-number">1.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBulider%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">String、StringBuffer、StringBulider三者的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#finall%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.</span> <span class="toc-text">finall关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%92%8Cequals"><span class="toc-number">4.</span> <span class="toc-text">&#x3D;&#x3D;和equals()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99%E4%BA%86equals-%E8%BF%98%E8%A6%81%E9%87%8D%E5%86%99hashcode"><span class="toc-number">5.</span> <span class="toc-text">为什么重写了equals()还要重写hashcode()?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#list%E6%8E%A5%E5%8F%A3%E5%92%8Cset%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">list接口和set接口的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">接口和抽象类的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.</span> <span class="toc-text">重载和重写的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">ArrayList和LinkedList的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#obj-hashCode%E5%92%8CStringhashCode"><span class="toc-number">10.</span> <span class="toc-text">obj.hashCode和StringhashCode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK1-8%E4%BB%A5%E5%90%8E%E7%9A%84HashMap%E5%9C%A8%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6%E8%BF%87%E9%95%BF%E6%97%B6%E4%BC%9A%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%8C%E5%AF%B9%E6%AD%A4%E4%BD%A0%E6%80%8E%E4%B9%88%E7%9C%8B%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">JDK1.8以后的HashMap在链表长度过长时会转换为红黑树，对此你怎么看？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cookie%E5%92%8CSession"><span class="toc-number">12.</span> <span class="toc-text">cookie和Session</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">String的常用方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFsession%E5%85%B1%E4%BA%AB"><span class="toc-number">14.</span> <span class="toc-text">1、什么是session共享</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8redis%E6%9D%A5%E5%AD%98"><span class="toc-number">14.0.1.</span> <span class="toc-text">为什么要使用redis来存?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">14.1.</span> <span class="toc-text">2、什么是缓存？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%A6%82%E5%BF%B5"><span class="toc-number">14.1.1.</span> <span class="toc-text">缓存概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">14.1.2.</span> <span class="toc-text">为什么需要缓存？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">14.2.</span> <span class="toc-text">3、缓存的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%B7%BB%E5%8A%A0Redis%E7%BC%93%E5%AD%98%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">14.3.</span> <span class="toc-text">4、添加Redis缓存的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">14.4.</span> <span class="toc-text">5、缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="toc-number">14.4.0.1.</span> <span class="toc-text">产生原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E4%B8%BA%E4%BA%86%E5%87%8F%E5%B0%91%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%8C%E9%99%8D%E4%BD%8E%E8%AF%B7%E6%B1%82%E5%8E%8B%E5%8A%9B%EF%BC%89"><span class="toc-number">14.4.0.2.</span> <span class="toc-text">解决方案（为了减少访问数据库的次数，降低请求压力）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%E8%88%AC%E9%80%89%E6%8B%A9%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-number">14.4.0.2.1.</span> <span class="toc-text">1. 缓存空对象（一般选择这种方式）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4"><span class="toc-number">14.4.0.2.2.</span> <span class="toc-text">2. 布隆过滤</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">14.5.</span> <span class="toc-text">6、缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">14.5.1.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%BB%99%E4%B8%8D%E5%90%8C%E7%9A%84key%E7%9A%84TTL%E6%B7%BB%E5%8A%A0%E9%9A%8F%E6%9C%BA%E5%80%BC"><span class="toc-number">14.5.1.1.</span> <span class="toc-text">1、给不同的key的TTL添加随机值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%88%A9%E7%94%A8Redis%E9%9B%86%E7%BE%A4%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%EF%BC%88%E9%81%BF%E5%85%8DRedis%E5%AE%95%E6%9C%BA%E5%AF%BC%E8%87%B4%E7%9A%84%E9%9B%AA%E5%B4%A9%EF%BC%89"><span class="toc-number">14.5.1.2.</span> <span class="toc-text">2、利用Redis集群提高服务的可用性（避免Redis宕机导致的雪崩）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%BB%99%E7%BC%93%E5%AD%98%E4%B8%9A%E5%8A%A1%E6%B7%BB%E5%8A%A0%E9%99%8D%E7%BA%A7%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5"><span class="toc-number">14.5.1.3.</span> <span class="toc-text">3、给缓存业务添加降级限流策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E7%BB%99%E4%B8%9A%E5%8A%A1%E6%B7%BB%E5%8A%A0%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">14.5.1.4.</span> <span class="toc-text">4、给业务添加多级缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">14.6.</span> <span class="toc-text">7、缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">14.6.0.0.1.</span> <span class="toc-text">解决方案：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">14.6.0.0.1.1.</span> <span class="toc-text">1、互斥锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-number">14.6.0.0.1.2.</span> <span class="toc-text">互斥锁实现逻辑：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%EF%BC%88%E4%B8%8D%E6%98%AF%E7%9C%9F%E7%9A%84%E8%BF%87%E6%9C%9F%EF%BC%8C%E6%B0%B8%E4%B8%8D%E8%BF%87%E6%9C%9F%EF%BC%89"><span class="toc-number">14.6.0.0.1.3.</span> <span class="toc-text">2、逻辑过期（不是真的过期，永不过期）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-number">14.6.0.0.1.4.</span> <span class="toc-text">逻辑过期实现逻辑：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">14.6.0.0.2.</span> <span class="toc-text">两种方案的优缺点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">14.7.</span> <span class="toc-text">8、分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F"><span class="toc-number">14.7.1.</span> <span class="toc-text">8.1、什么是分布式锁？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%9C%A8MySQL%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2SQL"><span class="toc-number">14.8.</span> <span class="toc-text">9、在MySQL中，如何定位慢查询SQL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E5%AF%B9%E4%BA%8E%E6%89%A7%E8%A1%8C%E5%BE%97%E5%BE%88%E6%85%A2%E7%9A%84SQL%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">14.9.</span> <span class="toc-text">10、对于执行得很慢的SQL，该如何处理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E8%A1%A8%EF%BC%8C%E5%8F%AA%E6%9C%89%E5%9B%9B%E4%B8%AA%E5%AD%97%E6%AE%B5%EF%BC%8C%E6%9C%89%E4%B8%A4%E7%99%BE%E4%B8%87%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%83%B3%E8%A6%81%E5%BF%AB%E9%80%9F%E8%AE%BF%E9%97%AE%EF%BC%8C%E9%9C%80%E8%A6%81%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%90%97"><span class="toc-number">14.10.</span> <span class="toc-text">11、如果一个数据表，只有四个字段，有两百万的数据，想要快速访问，需要建索引吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">14.11.</span> <span class="toc-text">12、什么是索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">14.12.</span> <span class="toc-text">13、什么是聚集索引，什么是二级索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">14.13.</span> <span class="toc-text">14、什么是覆盖索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%85%B3%E9%94%AE%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">14.14.</span> <span class="toc-text">15、索引的设计关键原则有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5"><span class="toc-number">14.15.</span> <span class="toc-text">16、索引失效情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9SQL%E4%BC%98%E5%8C%96%E7%9A%84%E7%BB%8F%E9%AA%8C%E3%80%82"><span class="toc-number">14.16.</span> <span class="toc-text">17、谈谈你对SQL优化的经验。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81%E4%BA%8B%E5%8A%A1"><span class="toc-number">14.17.</span> <span class="toc-text">18、事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">14.17.1.</span> <span class="toc-text">1、四大特性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">14.17.2.</span> <span class="toc-text">2、并发事务引发的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">14.17.3.</span> <span class="toc-text">3、事务隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81undo-log%E5%92%8Credo-logo"><span class="toc-number">14.17.4.</span> <span class="toc-text">4、undo log和redo logo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8Bmvcc"><span class="toc-number">14.17.5.</span> <span class="toc-text">5、解释一下mvcc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">14.18.</span> <span class="toc-text">19、主从同步原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">14.19.</span> <span class="toc-text">20、分库分表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81%EF%BC%88%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%89redis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%EF%BC%8Cmysql%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%B8%8Eredis%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5%E5%91%A2"><span class="toc-number">14.20.</span> <span class="toc-text">21、（双写一致性）redis作为缓存，mysql的数据如何与redis进行同步呢</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-number">14.21.</span> <span class="toc-text">22、redis的持久化是怎么做的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8Bbean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">14.22.</span> <span class="toc-text">23、spring框架中的单例bean是线程安全的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81Spring%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3"><span class="toc-number">14.23.</span> <span class="toc-text">24、Spring框架常见注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81Springboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">14.24.</span> <span class="toc-text">25、Springboot自动配置原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">14.25.</span> <span class="toc-text">26、bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">14.26.</span> <span class="toc-text">27、事务失效的场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E5%A4%84%E7%90%86%E4%BD%86%E4%B8%8D%E6%8A%9B%E5%87%BA"><span class="toc-number">14.26.1.</span> <span class="toc-text">1、异常捕获处理但不抛出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%8A%9B%E5%87%BA%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">14.26.2.</span> <span class="toc-text">2、抛出编译时异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E9%9D%9Epublic%E6%96%B9%E6%B3%95%E5%AF%BC%E8%87%B4%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88"><span class="toc-number">14.26.3.</span> <span class="toc-text">3、非public方法导致的事务失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1"><span class="toc-number">14.26.4.</span> <span class="toc-text">4、数据库不支持事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.27.</span> <span class="toc-text">28、线程和进程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.28.</span> <span class="toc-text">29、并行与并发的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">14.29.</span> <span class="toc-text">30、创建线程的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E7%BA%BF%E7%A8%8B%E5%8C%85%E5%90%AB%E4%BA%86%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81"><span class="toc-number">14.30.</span> <span class="toc-text">31、线程包含了哪些状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E3%80%81%E6%9C%89%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BB%96%E4%BB%AC%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">14.31.</span> <span class="toc-text">32、有三个线程，如何让他们顺序执行？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E3%80%81notify-%E5%92%8CnotifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">14.32.</span> <span class="toc-text">33、notify()和notifyAll()有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81wait%E5%92%8Csleep%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">14.33.</span> <span class="toc-text">34、wait和sleep方法的不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81Synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">14.34.</span> <span class="toc-text">35、Synchronized底层原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-number">14.35.</span> <span class="toc-text">36、说一下线程池的核心参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">14.36.</span> <span class="toc-text">37、线程池的执行原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38%E3%80%81%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E7%9A%84%E8%AE%BE%E7%BD%AE%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%EF%BC%9F"><span class="toc-number">14.37.</span> <span class="toc-text">38、如何合理的设置核心线程数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">14.38.</span> <span class="toc-text">39、分布式锁的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">14.39.</span> <span class="toc-text">40、分布式锁的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E7%9A%84%E6%8E%A7%E5%88%B6%E9%94%81%E8%BF%87%E6%9C%9F%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%9F"><span class="toc-number">14.39.1.</span> <span class="toc-text">1、如何合理的控制锁过期的时间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Redisson%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%88%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%89"><span class="toc-number">14.39.2.</span> <span class="toc-text">2、Redisson实现分布式锁的原理（可重入锁）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E3%80%81redisson-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%BA%95%E5%B1%82%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8setnx%E5%92%8Clua%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B8%A4%E8%80%85%E5%88%86%E5%88%AB%E8%B5%B7%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">14.40.</span> <span class="toc-text">41、redisson 实现分布式锁的底层为什么要用setnx和lua？它们两者分别起到了什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E3%80%81TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">14.41.</span> <span class="toc-text">42、TCP的三次握手机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43%E3%80%81TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">14.42.</span> <span class="toc-text">43、TCP四次挥手</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/25/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%BB%8E%E6%89%93%E5%8C%85%E5%88%B0%E4%B8%8A%E7%BA%BF/" title="无题">无题</a><time datetime="2024-01-24T17:54:03.623Z" title="发表于 2024-01-25 01:54:03">2024-01-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/22/gradle%20Connection%20time%20out%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="gradle构建超时gradle connection timed out解决方案">gradle构建超时gradle connection timed out解决方案</a><time datetime="2024-01-22T08:04:01.000Z" title="发表于 2024-01-22 16:04:01">2024-01-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/18/Docker%E7%9A%84%E5%AE%89%E8%A3%85/" title="Docker的安装">Docker的安装</a><time datetime="2024-01-17T21:18:54.000Z" title="发表于 2024-01-18 05:18:54">2024-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/17/Ant-Design-pro%E5%88%A0%E9%99%A4%E5%9B%BD%E9%99%85%E5%8C%96%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="Ant-Design-pro删除国际化失败解决方案">Ant-Design-pro删除国际化失败解决方案</a><time datetime="2024-01-17T08:04:01.000Z" title="发表于 2024-01-17 16:04:01">2024-01-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/17/SpringBoot%E7%A6%81%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93/" title="SpringBoot项目禁用数据库">SpringBoot项目禁用数据库</a><time datetime="2024-01-17T06:25:39.000Z" title="发表于 2024-01-17 14:25:39">2024-01-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Pn</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer" data-id="1336871887" data-server="netease" data-type="song"  data-fixed="true" data-theme="#3F51B5" ></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>